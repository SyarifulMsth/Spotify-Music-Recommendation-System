# -*- coding: utf-8 -*-
"""Music Recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h33C29-4-sjlq2-1Z00yHRlVoQ9KgXB6

# Music Recommendation using Model Development Content Based Filtering

## Business Understanding

Building machine learning models for music recommendation

## Dataset Understanding

Pada proyek ini dataset yang digunakan adalah [Dataset Top Hits Spotify from 2000-2019](https://www.kaggle.com/datasets/paradisejoy/top-hits-spotify-from-20002019). Dataset tersebut terdiri dari 2000 *data records* dengan 18 *features*. Berikut adalah detail dari dataset yang digunakan pada proyek ini :

| Attribute | Description | Data Type |
|---|---|---|
| artist | Name of the artist who performs the song | Text |
| song | Title of the song | Text |
| duration_ms | Duration of the song in milliseconds | Integer |
| explicit | Indicates whether the song contains explicit lyrics or content | Boolean |
| year | Year the song was released | Integer |
| popularity | Popularity of the song | Integer |
| danceability | How suitable a song is for dancing based on a combination of musical elements | Decimal (0.0 - 1.0) |
| energy | Intensity and activity of the song | Decimal (0.0 - 1.0) |
| key | Key of the song | Integer (referring to the musical scale) |
| loudness | Loudness of the song in decibels (dB) | Decimal |
| mode | Indicates the scale of the song, major (value 1) or minor (value 0) | Integer |
| speechiness | Probability of the presence of spoken words in a song | Decimal (0.0 - 1.0) |
| acousticness | Confidence whether the track is acoustic | Decimal (0.0 - 1.0) |
| instrumentalness | Probability that a song contains no vocals | Decimal (0.0 - 1.0) |
| liveness | Probability that the song was recorded live | Decimal (0.0 - 1.0) |
| valence | Positivity conveyed by a track | Decimal (0.0 - 1.0) |
| tempo | Overall estimated tempo of a track in beats per minute (BPM) | Integer |
| genre | Genre of the song | Text |

**Notes:**

* The data type "Decimal" indicates a numeric value that ranges between 0.0 and 1.0.
* The data type "Integer" indicates a numeric value without a decimal point.

## Import Necessary Libraries
"""

# import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

# ignore warnings
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

"""### Gathering Data

**Dataset Source :** https://www.kaggle.com/datasets/paradisejoy/top-hits-spotify-from-20002019
"""

# Connect Google Colaboratory with Kaggle
! mkdir ~/.kaggle
! cp '/content/drive/MyDrive/Colab Notebooks/Kaggle API/kaggle.json' ~/.kaggle/kaggle.json
! chmod 600 ~/.kaggle/kaggle.json
! ls ~/.kaggle

! kaggle datasets download paradisejoy/top-hits-spotify-from-20002019

! unzip top-hits-spotify-from-20002019.zip -d /content/data/

"""### Data Assessing"""

df = pd.read_csv('/content/data/songs_normalize.csv')
print('Jumlah data musik : ', len(df.song.unique()))

df.head()

"""## Exploratory Data Analysis

"""

top_artists = df.sort_values(by='popularity', ascending=False).head(10)

plt.figure(figsize=(14, 8))
plot = sns.barplot(x='popularity', y='artist', data=top_artists, palette='pastel')
plt.title('Top 10 Artist dengan Popularity Tertinggi')
plt.xlabel('Popularity')
plt.ylabel('Artist')
for i in plot.patches:
    plot.text(i.get_width() + 0.2, i.get_y() + i.get_height()/2, str(round(i.get_width(), 2)), fontsize=10, color='black', ha='left', va='center')
plt.show()

plt.figure(figsize=(12, 6))
sns.countplot(x='year', data=df, palette='pastel')
plt.title('Jumlah Lagu Berdasarkan Tahun')
plt.xlabel('Tahun')
plt.ylabel('Jumlah Lagu')
plt.xticks(rotation=45)
plt.show()

"""### Univariate Exploratory Data Analysis

Seperti yang dapat dilihat pada hasil *gathering data* bahwa dataset yang digunakan pada proyek ini memiliki 18 *features*, yaitu :
- artist
- song
- duration_ms
- explicit
- year
- popularity
- danceability
- energy
- key
- loudness
- mode
- speechiness
- acousticness
- instrumentalness
- liveness
- valence
- tempo
- genre

Tahap eksplorasi penting untuk memahami variabel ataupun features pada data serta korelasi antar variabel. Pemahaman terhadap variabel pada data dan korelasinya akan membantu dalam menentukan pendekatan atau algoritma yang cocok untuk dataset yang digunakan.
"""

df.info()

"""Berdasarkan *output* di atas dapat diketahui bahwa pada dataset yang digunakan terdapat 2000 entri. Pada dataset ini, terdapat beberapa variabel yang akan digunakan dalam membuat model machine learning, di antaranya yaitu artist, song, year, popularity, danceability, energy, *speechiness*, *acousticness*, *instrumentalness*, valence, *tempo*, genre. Oleh karena itu, *features* lain yang tidak digunakan pada proyek ini akan dibuang / *dropping*."""

# Menghapus beberapa fitur dari DataFrame
features_to_drop = ['duration_ms', 'explicit', 'key', 'loudness', 'mode']
df_clean = df.drop(columns=features_to_drop)

# Memeriksa DataFrame setelah fitur dihapus
df = df_clean
df.head()

"""Untuk melihat ada berapa banyak entri yang unik untuk setiap *features* maka dapat dilakukan dengan cara sebagai berikut"""

print('Banyak data artist \t\t: ', len(df.artist.unique()))
print('Banyak data song \t\t: ', len(df.song.unique()))
print('Banyak data year \t\t: ', len(df.year.unique()))
print('Banyak data popularity \t\t: ', len(df.popularity.unique()))
print('Banyak data danceablity \t: ', len(df.danceability.unique()))
print('Banyak data energy \t\t: ', len(df.energy.unique()))
print('Banyak data speechiness \t: ', len(df.speechiness.unique()))
print('Banyak data acousticness \t: ', len(df.acousticness.unique()))
print('Banyak data instrumentalness \t: ', len(df.instrumentalness.unique()))
print('Banyak data valence \t\t: ', len(df.valence.unique()))
print('Banyak data tempo \t\t: ', len(df.tempo.unique()))
print('Banyak data genre \t\t: ', len(df.genre.unique()))

"""## Data Preparation"""

# memerika apakah terdapat missing value
df.isnull().sum()

"""Berdasarkan *output* di atas, pada dataset yang digunakan ini tidak terdapat *missing value*."""

# memeriksa apakah terdapat data yang duplicated
df.duplicated().sum()

# Menghilangkan data yang duplikat
df_clean = df.drop_duplicates()

# Memeriksa apakah data yang duplikat telah dihapus
print("Jumlah data sebelum dihapus duplikat:", len(df))
print("Jumlah data setelah dihapus duplikat:", len(df_clean))

df = df_clean

# Menampilkan nilai unik dari kolom 'year'
unique_year = df['year'].unique()
unique_year.sort()
unique_year

"""Apabila diperhatikan, lagu atau musik pada dataset yang digunakan pada proyek ini adalah lagu atau musik dari tahun 1998 hingga tahun 2000."""

# Menampilkan nilai unik dari kolom 'popularity' dengan mengurutkannya
unique_popularity = df['popularity'].unique()
unique_popularity.sort()
unique_popularity

"""Apabila diperhatikan, tingkat popularity lagu atau musik pada dataset ini beragam, yang paling rendah yaitu 0, sedangkan yang paling tinggi dalam kategori popularity yaitu 89."""

# Menampilkan nilai unik dari kolom 'genre'
unique_genre = df['genre'].unique()
print(unique_genre)

"""Apabila diperhatikan, terdapat beberapa genre lagu yang datanya memiliki lebih dari satu genre, dan genre tersebut muncul lebih dari satu kali. Hal ini tentunya akan berpengaruh pada performa model, sehinggda diperlukan penanganan untuk mengatasi hal ini. Misalnya "rock, pop", "rock, metal".

 Pada proyek ini, data yang akan diambil hanya kategori pertama untuk data yang memiliki genre lebih dari satu.


"""

# Memperbaiki kode untuk menangani kasus genre dengan tanda '/'
df['genre'] = df[~(df.genre.isna())]['genre'].apply(lambda x: x.split(',')[0] if x.split(',')[0] != "Hip Hop" else "Hip Hop" if '/' not in x else x)

print(df['genre'].value_counts())

"""Apabila diperhatikan, terdapat genre musik yang tidak wajar pada dataset, yaitu set(). Perlu dilakukan analisis lebih lanjut pada data tersebut."""

# Menampilkan data dengan genre "set"
set_songs = df[df['genre'] == 'set()']
set_songs

"""Setelah dilakukan analisis di atas, sebenarynya sayang jika data dengan genre set() tersebut langsung di-drop begitu saja. Namun,karena tidak bisa mengidentifikasi musik tersebut termasuk ke dalam genre musik mana. Oleh karena itu, untuk saat ini data tersebut akan dibuat / *dropping*.


"""

# Menghapus data dengan genre "set"
df = df[df['genre'] != 'set()']

# Menampilkan data dengan genre "set"
set_songs = df[df['genre'] == 'set()']
set_songs

genre_counts = df['genre'].value_counts()

plt.figure(figsize=(10, 6))
sns.barplot(x=genre_counts.index, y=genre_counts.values, palette='pastel')
plt.title('Jumlah data musik untuk setiap Genre')
plt.xlabel('Genre')
plt.ylabel('Jumlah Data')
plt.xticks(rotation=45)
plt.show()

"""## Model Development Content Based Filtering

Pada proyek ini, akan dilakukan tahapan membangun sistem rekomendasi musik berdasarkan jenis genre musik.
"""

data = df

data.head()

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tf.fit(data['genre'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(data['genre'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis masakan
# Baris diisi dengan nama resto

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=data.song
).sample(10, axis=1).sample(10, axis=0)

"""Berdasarkan *output* di atas, diperoleh hasil misalnya lagu dengan judul *Wish You Well* merupakan genre Pop, begitu pula dengan lagu *Not In Love - Radio Mix*, *Drunk in Love (feat Jay-Z)*, dan seterusnya.

Sampai tahapan ini, telah berhasil dilakukan identifikasi representasi fitur dengan fungsi tfidvectorizer. Selain itu, hasil dari matriks sebelumnya menunjukkan korelasi antara genre dengan judul lagu. Selanjutnya, akan dilakukan perhitungan derajat kesamaan antara satu lagu dengan lagu lainnya untuk menghasilkan kandidat lagu yang akan direkomendasikan.

## Cosine Similarity

Tahapan ini akan menggunakan fungsi [cosine_similarity](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.cosine_similarity.html)
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Pada tahapan ini, dilakukan perhitungan cosine similarity dataframe tfidf_matrix yang telah diperoleh pada tahapan sebelumnya. Dengan satu baris kode untuk memanggil fungsi cosine similarity dari library sklearn, maka telah berhasil dilakukan perhitungan kesamaan (similarity) antar lagu. Kode di atas menghasilkan keluaran berupa matriks kesamaan dalam bentuk array.

Selanjutnya yaitu melihat matriks kesamaan setiap lagu dengan menampilkan judul lagu dalam 5 sampel kolom (axis = 1) dan 10 sampel baris (axis=0).


"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul lagu
cosine_sim_df = pd.DataFrame(cosine_sim, index=data['song'], columns=data['song'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap lagu
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Berdasrkan *cosine similarity* di atas, dapat diidentifikasi kesamaan antara satu lagu dengan lagu lainnya. Shape (1919, 1919) merupakan ukuran matrik *similarity* dari data yang digunakan.Berdasarkan data yang ada, matrik di atas sebenarnya berukuran 1919 lagu x 1919 lagu (masing-masing dalam sumbu X dan Y). Artinya, telah dilakukan identifikasi tingkat kesamaan pada 1919 lagu. Tapi tentu hasilnya tidak dapat ditampilkan semuanya. Oleh karena itu, hanya 10 judul lagu pada vertikal dan 5 lagu pada sumbu horizontal yang ditampilkan seperti pada output di atas.

Apabila diperhatikan, dapat diidentifikasi bahwa lagu pada kolom X (horizontal) memiliki kesamaan dengan lagu pada baris Y (vertikal). Sebagai contoh lagu *My Band* teridentifikasi sama(similar) dengan lagu *Don't Mind*.

### top-N recommendation

Setelah memiliki data similarity (kesamaan) antar lagu. Selanjutnya yaitu menghasilkan sejumlah lagu yang akan direkomendasikan kepada pengguna.
"""

def lagu_recommendations(nama_lagu, similarity_data=cosine_sim_df, items=data[['song', 'genre']], k=5):
    """
    Rekomendasi lagu berdasarkan kemiripan dataframe

    Parameter:
    ---
    nama_lagu : tipe data string (str)
                Nama lagu (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan lagu sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_lagu].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop nama_lagu agar nama lagu yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_lagu, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Pada code di atas menggunakan *argpartition*, yang mana mengambail sejumlah nilai k tertinggi dari similarity data (dalam kasus ini: dataframe **cosine_sim_df**). Kemudian, diambil data dari bobot (tingkat kesamaan) tertinggi ke terendah. Data tersebut dimasukkan ke dalam variabel *closest*. Selanjutnya, menghapus lagu yang dicari agar tidak muncul dalam daftar rekomendasi. Dalam kasus ini, akan dicari lagu yang mirip dengan lagu dari Taylor Swift dengan judul **Love Story**."""

# Menampilkan daftar lagu dengan artis Taylor Swift
taylor_swift_songs = df[df['artist'] == 'Taylor Swift'].head()
taylor_swift_songs

data[data.song.eq('Love Story')]

"""Apabila diperhatikan, lagu Taylor Swift yang berjudul **Love Story** termasuk dalam genre **Pop**."""

# Mendapatkan rekomendasi lagu yang mirip dengan lagu Taylor Swift - Love Story
lagu_recommendations('Love Story')

"""Pada *output* di atas berhasil didapatkan 5 rekomendasi lagu yang memiliki kemiripan dengan lagu Taylor Swift - Love Story yang bergenre **POP**.

--- End of code ---
"""